# vim: set ft=ruby
<%
  def camel_case(name)
    name.split('_').map(&:capitalize).join
  end

  def repeat1(name, sep: [])
    <<-EOD
    #{name}s : 
        #{name}
        { [val[0]] }
      | #{name}s #{sep.join ' '} #{name}
        { val[0].push(val[#{sep.length + 1}]) }
    EOD
  end

  # sep: token needed in between the sequence
  # suffix: token needed at the end of the sequence
  def repeat0(name, sep: [], suffix: nil)
    <<-EOD
    opt_#{name}s :
        /* NONE */ 
      { [] }
      | #{name}s #{suffix}
      { val[0] }

    #{repeat1(name, sep: sep)}
    EOD
  end
%>
class Esquis::Parser
  options no_result_var
  token IDENT IVAR FLOAT INTEGER

  prechigh
    right UMINUS
    left '*' '/' '%'
    left '+' '-'
    left '>' '>=' '<' '<='
    nonassoc '==' '!='
    left '&&'
    left '||'
  preclow

rule
    program :
      opt_definitions
      opt_top_statements
      { Ast::Program.new(val[0], Ast::Main.new(val[1])) }

    # Same as statement but last `sep` is optional (i.e. `sep` is optional
    # at the end of the source file)
    top_statement:
        statement
    <%= repeat0 'top_statement', sep: ['sep'], suffix: 'opt_sep' %>

    definition :
        defclass
      | defun
      | extern
    <%= repeat0 'definition', sep: ['sep'], suffix: 'sep' %>

    defclass:
      'class' IDENT sep
        opt_defmethods
      'end'
      { Ast::DefClass.new(val[1], val[3]) }

    defmethod:
        definitialize
      | 'def' IDENT '(' opt_params ')' _nl '->' _nl IDENT sep
           opt_statements
        'end'
        { Ast::DefMethod.new(val[1], val[3], val[8], val[10]) }
    <%= repeat0 'defmethod', sep: ['sep'], suffix: 'sep' %>

    definitialize:
        'def' 'initialize' '(' opt_iparams ')' sep
          opt_statements
        'end'
      { Ast::DefInitialize.new(val[3], val[6]) }

    iparam : 
        param
      | IVAR ':' IDENT
      { Ast::Param.new(val[0], val[2]) }
    <%= repeat0 'iparam', sep: ["_nl", "','", "_nl"] %>

    defun:
      'def' IDENT '(' opt_params ')' _nl '->' _nl IDENT sep
         opt_statements
      'end'
      { Ast::Defun.new(val[1], val[3], val[8], val[10]) }
    <%= repeat0 'defun', sep: ['sep'] %>

    param : 
      IDENT ':' IDENT
      { Ast::Param.new(val[0], val[2]) }
    <%= repeat0 'param', sep: ["_nl", "','", "_nl"] %>

    extern:
        'extern' IDENT IDENT '(' opt_param_types ')'
      { Ast::Extern.new(val[1], val[2], val[4]) }

    param_type :
        IDENT
      { Ast::Param.new(nil, val[0]) }
    <%= repeat0 'param_type', sep: ["_nl", "','", "_nl"] %>

    statement:
        if_stmt
      | for_stmt
      | return_stmt
      | expression
      { Ast::ExprStmt.new(val[0]) }
    <%= repeat0 'statement', sep: ['sep'], suffix: 'sep' %>

    if_stmt:
        'if' expression sep opt_statements 'end'
      { Ast::If.new(val[1], val[3], []) }
      | 'if' expression sep opt_statements elsif_clause
      { Ast::If.new(val[1], val[3], val[4]) }

    elsif_clause:
        'elsif' expression sep opt_statements elsif_clause
      { [Ast::If.new(val[1], val[3], val[4])] }
      | 'elsif' expression sep opt_statements 'end'
      { [Ast::If.new(val[1], val[3], [])] }
      | 'else' opt_sep opt_statements 'end'
      { val[2] }

    for_stmt:
        'for' '(' IDENT ':' IDENT ';' expression '...' expression ';' expression ')' sep
          opt_statements
        'end'
      { Ast::For.new(val[2], val[4], val[6], val[8], val[10], val[13]) }

    return_stmt:
        'return' expression
      { Ast::Return.new(val[1]) }

    expression:
        method_call
      | fcall
      | assignment
      | varref
      | literal

      <% ops = %w(+ - * / % > < >= <= == != && ||) %>
      <% ops.each do |op| %>
      | expression '<%= op %>' expression
      { Ast::BinExpr.new("<%= op %>", val[0], val[2]) }
      <% end %>

      | '-' expression =UMINUS
      { Ast::UnaryExpr.new("-", val[1]) }

      | '(' expression ')'
      { val[1] }
    <%= repeat0 'expression' %>

    method_call:
        expression '.' IDENT '(' opt_args ')'
      { Ast::MethodCall.new(val[0], val[2], val[4]) }
      | expression '.' IDENT
      { Ast::MethodCall.new(val[0], val[2], []) }

    fcall:
        IDENT '(' opt_args ')'
      { Ast::FunCall.new(val[0], val[2]) }

    assignment:
        IDENT '=' expression
      { Ast::Assignment.new(val[0], val[2]) }

    arg:
        expression
    <%= repeat0 'arg', sep: ["_nl", "','", "_nl"] %>

    varref:
        IDENT
        { Ast::VarRef.new(val[0]) }
      | IVAR
        { Ast::VarRef.new(val[0]) }

    literal:
        FLOAT
      { Ast::Literal.new(val[0]) }
      | INTEGER
      { Ast::Literal.new(val[0]) }

    nl:
        '\n'

    _nl:
        /* NONE */
      | nl

    opt_sep:
        /* NONE */
      | sep

    sep:
        separator
      | sep separator

    separator:
        nl
      | ';'
end

---- header
require 'strscan'

---- inner
KEYWORDS = /extern|class|def|initialize|do|end|if|elsif|else|for|return/

SYMBOLS = Regexp.union(*"
... >= <= == != && || -> < > ( ) { } . + - * / % = , ; :
".split.map{|x| Regexp.new(Regexp.quote(x))})

def parse(str)
  @yydebug = true

  @q = []
  s = StringScanner.new(str)
  until s.empty?
    case
    when s.scan(/\n/)
      @q << ['\n', :NL]
    when s.scan(/\s+/)
      # skip whitespace
    when s.scan(%r{#[^\n]*})
      # skip comment
    when m = s.scan(SYMBOLS)
      @q << [m, :SYMBOL]
    when m = s.scan(/\d+\.\d+/)
      @q << [:FLOAT, m.to_f]
    when m = s.scan(/\d+/)
      @q << [:INTEGER, m.to_i]
    when m = s.scan(/#{KEYWORDS}\b/)
      @q << [m, :KEYWORD]
    when m = s.scan(/@[\w_]+/)
      @q << [:IVAR, m]
    when m = s.scan(/[\w_]+/)
      @q << [:IDENT, m]
    else
      raise "no match: #{s.inspect}"
    end
  end

  do_parse
rescue 
  #p q: @q
  raise
end

def next_token
  @q.shift
end
